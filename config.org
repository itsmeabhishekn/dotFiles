* Appearance
My Archmacs have killer looks. The code of this section is responsible for it.
** Theme
When my crush rejected me by saying you are ugly. I learned that looks matter alot.
My emacs will not be ugly like me and no one will dump my config for this.
So I decided to use =doom-themes=. You can change =doom-themes= to any other theme.
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
      :if window-system
      :ensure t
      :config
      (load-theme 'doom-molokai t)
      (doom-themes-org-config)
      (doom-themes-visual-bell-config)
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (fringe-mode -1)
      (scroll-bar-mode -1))
#+END_SRC
** Font
Just like with power comes great responsibility, with great theme comes great font.
Here I use =JetBrains Mono= Which is similar to =fira=. Feel free to change if you
have shitty taste.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist
	       '(font . "JetBrains Mono-14"))
#+END_SRC

* Basic Interface Settings
These are settings that do not depend on packages and built-in enchancements to the UI.
** Looks
*** Remove lame startup screen
We use an actual replacement for it, keep reading or head directly to dashboard
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

*** Disable menus and scrollbars
If you like using any of those, change =-1= to =1=.
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

*** Disable bell
This is annoying, remove this line if you like being visually reminded of events.
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

*** Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

** Functionality
*** Disable backups and auto-saves
I don't use either, you might want to turn those from =nil= to =t= if you do.

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+END_SRC

*** Change yes-or-no questions into y-or-n questions

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Async
Lets us use asynchronous processes whereever possible, pretty useful.
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t
    :init (dired-async-mode 1))
#+END_SRC

** Cool Icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t
    :init)

  (use-package all-the-icons-dired
    :ensure t
    :init (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

  (use-package all-the-icons-ibuffer
    :ensure t
    :init (all-the-icons-ibuffer-mode 1))
#+END_SRC

** Async
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t
    :init (dired-async-mode 1))
#+END_SRC

* Terminal
Not having a cool terminal inside your text editor is a crime, exactly like saying
Archmacs text editor which I just did.
**  Vterm
Many emacs users including me like vterm. It's more solid and polished. I bind =s-return= 
to open terminal because I know you always want terminal ASAP.
#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :ensure t
    :init
    (global-set-key (kbd "<c-return>") 'vterm))
#+END_SRC
** 

* Dashboard
This is your new startup screen, together with projectile it works in unison and provides 
you with a quick look into you latest projects and files. Change the welcome message to whatever string
you want and change the numbers to suit you liking, I find 5 to be enough.
I also added my image and a cool line from show one punch man, you may want to change that.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
      (dashboard-setup-startup-hook)
      (setq dashboard-startup-banner "~/.emacs.d/img/avatar.png")
      (setq dashboard-items '((recents  . 5)
			      (projects . 5)))
      (setq dashboard-banner-logo-title "wubba lubba dub dub"))
#+END_SRC

* Modeline
The modeline is the heart of emacs, it displays information about modes and states 
you are in. 
** Spaceline
=Spaceline= is a mode-line theme for spacemacs. It's is simple and looks good.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :config
    (require 'spaceline-config)
    (setq powerline-default-separator (quote arrow))
    (spaceline-spacemacs-theme))
#+END_SRC
** Diminish Modes
By default there is alot of garbage information about many minor modes in modeline which we
don't want to display. =Diminish= is a package which allow us to remove those.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :init
    (diminish 'which-key-mode)
    (diminish 'linum-relative-mode)
    (diminish 'hungry-delete-mode)
    (diminish 'visual-line-mode)
    (diminish 'subword-mode)
    (diminish 'beacon-mode)
    (diminish 'irony-mode)
    (diminish 'page-break-lines-mode)
    (diminish 'auto-revert-mode)
    (diminish 'rainbow-delimiters-mode)
    (diminish 'rainbow-mode)
    (diminish 'yas-minor-mode)
    (diminish 'flycheck-mode)
    (diminish 'helm-mode))
#+END_SRC

** System load
By default emacs show system load information which is completely useless to me. 
So It's better to remove it.
#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average nil)
#+END_SRC
** Fancy Battery 
=fancy-battery= is a /melpa/ package to display battery information at modeline. So yeah in 
Archmacs you can see battery status inside emacs easily. It's also have lot of fancy way to 
warn about low battery and all the other stuff.
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :init
    (fancy-battery-mode 1)
    (setq fancy-battery-show-percentage t))
#+END_SRC

* Minor Conveiniences
Emacs is at it's best when it just does things for you, shows you the way, guides you so to
speak. This can be best achieved using a number of small extensions. While on their own they
might not be particularly impressive. 
** Visiting the configuration
Since this config is like a complete doc, it's better to bind a key to open it.
I bind =C-c e= to quickly open =~/.emacs.d/config.org=.
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC
** Reloading the configuration
Closing and opening emacs again after some quick changes in config is pain, especially when
you are using emacs as a window manager. So here I bind a key =C-c r= to do it quickly without
closing emacs. 
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC
** Subwords
Subword will remaps word-based editing commands to subword-based commands that 
handle symbols with mixed uppercase and lowercase letters.
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC
** Electric pair mode
Electric Pair mode, a global minor mode, provides a way to easily insert matching delimiters:
parentheses, braces, brackets, etc. 
#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '(
			     (?\{ . ?\})
			     (?\( . ?\))
			     (?\[ . ?\])
			     (?\" . ?\")
			     ))
  (electric-pair-mode t)
#+END_SRC
** Kill whole word
This is a function which allow you to delete a complete word with one keybind. My keybind
for deleting a word is =C-c w w=. I wish emacs have this feature by default.
#+BEGIN_SRC emacs-lisp
  (defun kill-whole-word ()
    (interactive)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "C-c w w") 'kill-whole-word)
#+END_SRC
** Hungry delete
I hate pressing backspace and waiting for deleting whitespaces. This package =hungry-delete=
delete all whitespaces with just one click on backspace.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :config (global-hungry-delete-mode))
#+END_SRC
** Copy whole line
Emacs by default don't have any function which copy the whole line. But gladly emacs gave us
power to write our own functions. So I write my own and bind it to =C-c w l=. 
#+BEGIN_SRC emacs-lisp
  (defun copy-whole-line ()
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
	(point-at-bol)
	(point-at-eol)))))
  (global-set-key (kbd "C-c w l") 'copy-whole-line)
#+END_SRC
** Beacon
While changing buffers or workspaces, the first thing you do is look for you cursor. Unless 
you know its position, you can not move it efficiently. Every time you change buffers, the 
current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
      (beacon-mode 1))
#+END_SRC
** Rainbow
Mostly useful if you are into web development or game development. Every time emacs encounters
a hexadeimal code that resembles a color, it will automatically highlight it in the appropriate
color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC
** Rainbow Delimiter
Colors parentheses and other delimiters depending on their depth, useful for any language
using them, especially lisp.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
    (rainbow-delimiters-mode 1))
#+END_SRC
** Expand region
A pretty simple package, takes your cursor and sementically expands the region, so words, 
sentencies, maybe the contents of some parentheses, it's awesome, try it out.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-q" . er/expand-region))
#+END_SRC
** Zapping to char
A nifty little package that kills all text between your cursor and a selected character. A lot
more useful than you might think. If you with to include the selected character in the killed
region, change =zzz-up-to-char= into =zzz-to-char=.
#+BEGIN_SRC emacs-lisp
  (use-package zzz-to-char
    :ensure t
    :bind ("M-z" . zzz-up-to-char))
#+END_SRC

* Kill ring
There is lot of cutomization to the kill ring, and while I have not used it much before, I 
decided that it was time to change that.
** Maximum entried on the ring
The default is 60, I personally need more sometimes.
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 100)
#+END_SRC
** popup-kill-ring
Out of all the packages I tried out, this one being the simplest, appealed to me most. With a
simple M-y you can now browse your kill-ring like browsing autocompletion items. C-n and C-p
totally work for this.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
* Git integration
Countless are the times where I opened vterm and use =git= on something. These times are also 
something that I'd prefer stay in the past, since =magit= is great. It's easy and intuitive to
use, shows its options at a keypress and much more.
** Magit
=magit= is a amazing /melpa/ package which allow me to use git within emacs more better way.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    :bind
    ("M-g" . magit-status))
#+END_SRC
* Sudo edit
Opening nano to edit files which require root permission is pain in the butt. This package
=sudo-edit= allow us to edit files which require root permission with emacs.
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind ("s-e" . sudo-edit))
#+END_SRC

* Org
One of the absolute greatest features of emacs is called “org-mode”. This very file has been
written in org-mode, a lot of other configurations are written in org-mode, same goes for
academic papers, presentations, schedules, blogposts and guides. Org-mode is one of the most
complex things ever, lets make it a bit more usable with some basic configuration.

Those are all rather self-explanatory.
** Common Settings
These are just some common settings which makes working in org mode more better.
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " ")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC
** Org Bullets
Pretty bullets to make your org file more pretty and managed.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
* Buffers
Workflow with emacs depends alot on Buffers. If you know how to quickly change and manage 
buffers, you are not a novice in emacs. Sadly by default emacs have some bad way to manage
buffers. Here I tried to encounter those issues.
*** Always murder current buffer
Doing =C-x k= should kill the current buffer at all times. 
#+BEGIN_SRC emacs-lisp
  (defun kill-curr-buffer ()
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-curr-buffer)
#+END_SRC
*** Toggle maximize buffer
An Emacs function to temporarily make one buffer fullscreen. You can quickly restore the old window setup. 
#+BEGIN_SRC emacs-lisp
  (defun toggle-maximize-buffer () "Maximize buffer"
         (interactive)
         (if (= 1 (length (window-list)))
             (jump-to-register '_)
           (progn
             (set-register '_ (list (current-window-configuration)))
             (delete-other-windows))))
  (global-set-key [(super shift return)] 'toggle-maximize-buffer) 
#+END_SRC

* Which Key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode))
#+END_SRC
* Text Manipulation
* IDO
** Enable IDO mode
#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
#+END_SRC

** IDO vertical
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :init
    (ido-vertical-mode 1))
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+END_SRC

** Smex
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :init (smex-initialize)
    :bind
    ("M-x" . smex))
#+END_SRC

* Buffers
** Enable ibuffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

** Expert mode
#+BEGIN_SRC emacs-lisp
  (setq ibuffer-expert t)
#+END_SRC

** Kill all buffers
#+BEGIN_SRC emacs-lisp
  (defun kill-all-buffers ()
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'kill-all-buffers)
#+END_SRC

* Avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
    ("C-." . avy-goto-char))
#+END_SRC


* Moving Around Emacs
** Switch Window
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :ensure t
    :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
	  '("a" "s" "d" "f" "h" "j" "k" "l"))
    :bind
    ([remap other-window] . switch-window))
#+END_SRC

** Following window splits
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

* Auto Completion
** Company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 1)
    (setq company-minimum-prefix-length 3)
    :init
    (company-mode 1))

  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "SPC") #'company-abort))
#+END_SRC

* Swiper
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind ("C-s" . swiper))
#+END_SRC

* Clock
  A clock to see time. Because time is important. 
** Time Format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M")
#+END_SRC

** Enabling the mode
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC


* Dired Launch
#+BEGIN_SRC emacs-lisp
  (use-package dired-launch
    :ensure t
    :init
    (dired-launch-enable))
#+END_SRC


